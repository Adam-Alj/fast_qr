//! Contains all different levels of quality.
//! And allows to find easily max bits per version/quality pair

/// Error Correction Coding has 4 levels
#[allow(dead_code)]
pub enum ECL {
    /// Low, 7%
    L,
    /// Medium, 15%
    M,
    /// Quartile, 25%
    Q,
    /// High, 30%
    H,
}

/// Contains the max bits for any version of `LOW` ECC
const L_DATABITS: [u16; 41] = [
    0, 152, 272, 440, 640, 864, 1088, 1248, 1552, 1856, 2192, 2592, 2960, 3424, 3688, 4184, 4712,
    5176, 5768, 6360, 6888, 7456, 8048, 8752, 9392, 10208, 10960, 11744, 12248, 13048, 13880,
    14744, 15640, 16568, 17528, 18448, 19472, 20528, 21616, 22496, 23648,
];

/// Contains the max bits for any version of `MED` ECC
const M_DATABITS: [u16; 41] = [
    0, 128, 224, 352, 512, 688, 864, 992, 1232, 1456, 1728, 2032, 2320, 2672, 2920, 3320, 3624,
    4056, 4504, 5016, 5352, 5712, 6256, 6880, 7312, 8000, 8496, 9024, 9544, 10136, 10984, 11640,
    12328, 13048, 13800, 14496, 15312, 15936, 16816, 17728, 18672,
];

/// Contains the max bits for any version of `QAR` ECC
const Q_DATABITS: [u16; 41] = [
    0, 104, 176, 272, 384, 496, 608, 704, 880, 1056, 1232, 1440, 1648, 1952, 2088, 2360, 2600,
    2936, 3176, 3560, 3880, 4096, 4544, 4912, 5312, 5744, 6032, 6464, 6968, 7288, 7880, 8264, 8920,
    9368, 9848, 10288, 10832, 11408, 12016, 12656, 13328,
];

/// Contains the max bits for any version of `HIG` ECC
const H_DATABITS: [u16; 41] = [
    0, 72, 128, 208, 288, 368, 480, 528, 688, 800, 976, 1120, 1264, 1440, 1576, 1784, 2024, 2264,
    2504, 2728, 3080, 3248, 3536, 3712, 4112, 4304, 4768, 5024, 5288, 5608, 5960, 6344, 6760, 7208,
    7688, 7888, 8432, 8768, 9136, 9776, 10208,
];

/// Fetches the right array to retrieve numer of databits
pub const fn ecc_to_databits(quality: ECL, version: usize) -> u16 {
    if version <= 0 || version >= 41 {
        panic!("Version should be between 1 and 40 included");
    }

    return match quality {
        ECL::L => L_DATABITS[version],
        ECL::M => M_DATABITS[version],
        ECL::Q => Q_DATABITS[version],
        ECL::H => H_DATABITS[version],
    };
}

/// Contains the number of Data Codewords for a version at level L
const L_ECT: [usize; 41] = [
    0, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30,
    30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
];

/// Contains the number of Data Codewords for a version at level M
const M_ECT: [usize; 41] = [
    0, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28,
    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
];

/// Contains the number of Data Codewords for a version at level Q
const Q_ECT: [usize; 41] = [
    0, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30,
    30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
];

/// Contains the number of Data Codewords for a version at level H
const H_ECT: [usize; 41] = [
    0, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
];

/// Fetches the right array to retrieve numer of error correction code words
pub const fn ecc_to_ect(quality: ECL, version: usize) -> usize {
    if version <= 0 || version >= 41 {
        panic!("Version should be between 1 and 40 included");
    }

    return match quality {
        ECL::L => L_ECT[version],
        ECL::M => M_ECT[version],
        ECL::Q => Q_ECT[version],
        ECL::H => H_ECT[version],
    };
}

const L_GROUPS: [[(u8, u8); 2]; 41] = [
    [(0, 0), (0, 0)],
    [(1, 19), (0, 0)],
    [(1, 34), (0, 0)],
    [(1, 55), (0, 0)],
    [(1, 80), (0, 0)],
    [(1, 108), (0, 0)],
    [(2, 68), (0, 0)],
    [(2, 78), (0, 0)],
    [(2, 97), (0, 0)],
    [(2, 116), (0, 0)],
    [(2, 68), (2, 69)],
    [(4, 81), (0, 0)],
    [(2, 92), (2, 93)],
    [(4, 107), (0, 0)],
    [(3, 115), (1, 116)],
    [(5, 87), (1, 88)],
    [(5, 98), (1, 99)],
    [(1, 107), (5, 108)],
    [(5, 120), (1, 121)],
    [(3, 113), (4, 114)],
    [(3, 107), (5, 108)],
    [(4, 116), (4, 117)],
    [(2, 111), (7, 112)],
    [(4, 121), (5, 122)],
    [(6, 117), (4, 118)],
    [(8, 106), (4, 107)],
    [(10, 114), (2, 115)],
    [(8, 122), (4, 123)],
    [(3, 117), (10, 118)],
    [(7, 116), (7, 117)],
    [(5, 115), (10, 116)],
    [(13, 115), (3, 116)],
    [(17, 115), (0, 0)],
    [(17, 115), (1, 116)],
    [(13, 115), (6, 116)],
    [(12, 121), (7, 122)],
    [(6, 121), (14, 122)],
    [(17, 122), (4, 123)],
    [(4, 122), (18, 123)],
    [(20, 117), (4, 118)],
    [(19, 118), (6, 119)],
];

const M_GROUPS: [[(u8, u8); 2]; 41] = [
    [(0, 0), (0, 0)],
    [(1, 16), (0, 0)],
    [(1, 28), (0, 0)],
    [(1, 44), (0, 0)],
    [(2, 32), (0, 0)],
    [(2, 43), (0, 0)],
    [(4, 27), (0, 0)],
    [(4, 31), (0, 0)],
    [(2, 38), (2, 39)],
    [(3, 36), (2, 37)],
    [(4, 43), (1, 44)],
    [(1, 50), (4, 51)],
    [(6, 36), (2, 37)],
    [(8, 37), (1, 38)],
    [(4, 40), (5, 41)],
    [(5, 41), (5, 42)],
    [(7, 45), (3, 46)],
    [(10, 46), (1, 47)],
    [(9, 43), (4, 44)],
    [(3, 44), (11, 45)],
    [(3, 41), (13, 42)],
    [(17, 42), (0, 0)],
    [(17, 46), (0, 0)],
    [(4, 47), (14, 48)],
    [(6, 45), (14, 46)],
    [(8, 47), (13, 48)],
    [(19, 46), (4, 47)],
    [(22, 45), (3, 46)],
    [(3, 45), (23, 46)],
    [(21, 45), (7, 46)],
    [(19, 47), (10, 48)],
    [(2, 46), (29, 47)],
    [(10, 46), (23, 47)],
    [(14, 46), (21, 47)],
    [(14, 46), (23, 47)],
    [(12, 47), (26, 48)],
    [(6, 47), (34, 48)],
    [(29, 46), (14, 47)],
    [(13, 46), (32, 47)],
    [(40, 47), (7, 48)],
    [(18, 47), (31, 48)],
];

const Q_GROUPS: [[(u8, u8); 2]; 41] = [
    [(0, 0), (0, 0)],
    [(1, 13), (0, 0)],
    [(1, 22), (0, 0)],
    [(2, 17), (0, 0)],
    [(2, 24), (0, 0)],
    [(2, 15), (2, 16)],
    [(4, 19), (0, 0)],
    [(2, 14), (4, 15)],
    [(4, 18), (2, 19)],
    [(4, 16), (4, 17)],
    [(6, 19), (2, 20)],
    [(4, 22), (4, 23)],
    [(4, 20), (6, 21)],
    [(8, 20), (4, 21)],
    [(11, 16), (5, 17)],
    [(5, 24), (7, 25)],
    [(15, 19), (2, 20)],
    [(1, 22), (15, 23)],
    [(17, 22), (1, 23)],
    [(17, 21), (4, 22)],
    [(15, 24), (5, 25)],
    [(17, 22), (6, 23)],
    [(7, 24), (16, 25)],
    [(11, 24), (14, 25)],
    [(11, 24), (16, 25)],
    [(7, 24), (22, 25)],
    [(28, 22), (6, 23)],
    [(8, 23), (26, 24)],
    [(4, 24), (31, 25)],
    [(1, 23), (37, 24)],
    [(15, 24), (25, 25)],
    [(42, 24), (1, 25)],
    [(10, 24), (35, 25)],
    [(29, 24), (19, 25)],
    [(44, 24), (7, 25)],
    [(39, 24), (14, 25)],
    [(46, 24), (10, 25)],
    [(49, 24), (10, 25)],
    [(48, 24), (14, 25)],
    [(43, 24), (22, 25)],
    [(34, 24), (34, 25)],
];

const H_GROUPS: [[(u8, u8); 2]; 41] = [
    [(0, 0), (0, 0)],
    [(1, 9), (0, 0)],
    [(1, 16), (0, 0)],
    [(2, 13), (0, 0)],
    [(4, 9), (0, 0)],
    [(2, 11), (2, 12)],
    [(4, 15), (0, 0)],
    [(4, 13), (1, 14)],
    [(4, 14), (2, 15)],
    [(4, 12), (4, 13)],
    [(6, 15), (2, 16)],
    [(3, 12), (8, 13)],
    [(7, 14), (4, 15)],
    [(12, 11), (4, 12)],
    [(11, 12), (5, 13)],
    [(11, 12), (7, 13)],
    [(3, 15), (13, 16)],
    [(2, 14), (17, 15)],
    [(2, 14), (19, 15)],
    [(9, 13), (16, 14)],
    [(15, 15), (10, 16)],
    [(19, 16), (6, 17)],
    [(34, 13), (0, 0)],
    [(16, 15), (14, 16)],
    [(30, 16), (2, 17)],
    [(22, 15), (13, 16)],
    [(33, 16), (4, 17)],
    [(12, 15), (28, 16)],
    [(11, 15), (31, 16)],
    [(19, 15), (26, 16)],
    [(23, 15), (25, 16)],
    [(23, 15), (28, 16)],
    [(19, 15), (35, 16)],
    [(11, 15), (46, 16)],
    [(59, 16), (1, 17)],
    [(22, 15), (41, 16)],
    [(2, 15), (64, 16)],
    [(24, 15), (46, 16)],
    [(42, 15), (32, 16)],
    [(10, 15), (67, 16)],
    [(20, 15), (61, 16)],
];

pub const fn ecc_to_groups(quality: ECL, version: usize) -> [(u8, u8); 2] {
    if version <= 0 || version >= 41 {
        panic!("Version should be between 1 and 40 included");
    }

    return match quality {
        ECL::L => L_GROUPS[version],
        ECL::M => M_GROUPS[version],
        ECL::Q => Q_GROUPS[version],
        ECL::H => H_GROUPS[version],
    };
}
